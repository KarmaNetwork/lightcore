pub use super::handler::{PingConfig, PingResult, PingSuccess, PingFailure};
use super::handler::PingHandler;

use futures::prelude::*;
use libp2p::core::{ConnectedPoint, Multiaddr, PeerId};
use libp2p::swarm::{NetworkBehaviour, NetworkBehaviourAction, PollParameters};
use std::collections::VecDeque;
use std::marker::PhantomData;
use tokio_io::{AsyncRead, AsyncWrite};
use void::Void;

/// `Ping` is a [`NetworkBehaviour`] that responds to inbound pings and
/// periodically sends outbound pings on every established connection.
///
/// See the crate root documentation for more information.
pub struct Ping<TSubstream> {
    /// Configuration for outbound pings.
    config: PingConfig,
    /// Queue of events to yield to the swarm.
    events: VecDeque<PingEvent>,
    _marker: PhantomData<TSubstream>,
}

/// Event generated by the `Ping` network behaviour.
#[derive(Debug)]
pub struct PingEvent {
    /// The peer ID of the remote.
    pub peer: PeerId,
    /// The result of an inbound or outbound ping.
    pub result: PingResult,
}

impl<TSubstream> Ping<TSubstream> {
    /// Creates a new `Ping` network behaviour with the given configuration.
    pub fn new(config: PingConfig) -> Self {
        Ping {
            config,
            events: VecDeque::new(),
            _marker: PhantomData,
        }
    }
}

impl<TSubstream> Default for Ping<TSubstream> {
    fn default() -> Self {
        Ping::new(PingConfig::new())
    }
}

impl<TSubstream> NetworkBehaviour for Ping<TSubstream>
where
    TSubstream: AsyncRead + AsyncWrite,
{
    type ProtocolsHandler = PingHandler<TSubstream>;
    type OutEvent = PingEvent;

    fn new_handler(&mut self) -> Self::ProtocolsHandler {
        println!("[ping]: new handler...");
        PingHandler::new(self.config.clone())
    }

    fn addresses_of_peer(&mut self, _peer_id: &PeerId) -> Vec<Multiaddr> {
        println!("[ping]: address of peer...");
        Vec::new()
    }

    fn inject_connected(&mut self, peer: PeerId, _: ConnectedPoint) {
        println!("[ping]: connect {:?}", peer);
    }

    fn inject_disconnected(&mut self, _: &PeerId, _: ConnectedPoint) {}

    fn inject_node_event(&mut self, peer: PeerId, result: PingResult) {
        println!("[ping]: inject node event...");
        self.events.push_front(PingEvent { peer, result })
    }

    fn poll(&mut self, _: &mut impl PollParameters) -> Async<NetworkBehaviourAction<Void, PingEvent>>
    {
        if let Some(e) = self.events.pop_back() {
            println!("[ping]: poll...");
            Async::Ready(NetworkBehaviourAction::GenerateEvent(e))
        } else {
            Async::NotReady
        }
    }
}
